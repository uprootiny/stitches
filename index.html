<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="Research-grade LLM introspection with real probe data">
    <title>LLM Research Introspector</title>
    
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: rgba(5, 5, 15, 0.95);
            --border-primary: rgba(100, 200, 255, 0.4);
            --border-accent: rgba(255, 180, 100, 0.4);
            --text-primary: #e8e8e8;
            --text-secondary: #a8a8a8;
            --text-accent: #88ffaa;
            --research-highlight: #ff6b6b;
            --font-mono: 'SF Mono', 'Monaco', 'Menlo', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-primary);
            overflow: hidden;
            height: 100vh;
            font-family: var(--font-mono);
            color: var(--text-primary);
            touch-action: none;
            user-select: none;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #babylonCanvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
            touch-action: none;
        }

        /* Research-focused HUD overlay */
        .research-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 120px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            font-size: 11px;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .hud-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
        }

        .hud-label {
            color: var(--text-secondary);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .hud-value {
            color: var(--text-accent);
            font-weight: bold;
            font-size: 12px;
        }

        .probability-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .probability-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--research-highlight), var(--text-accent));
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .probability-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Bottom control panel for research parameters */
        .research-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 140px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-accent);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .control-tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            flex: 1;
            padding: 8px;
            text-align: center;
            font-size: 10px;
            text-transform: uppercase;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .tab.active {
            border-bottom-color: var(--border-accent);
            color: var(--text-accent);
        }

        .tab-content {
            display: none;
            flex: 1;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }

        .param-label {
            min-width: 80px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .param-control {
            flex: 1;
            height: 32px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 11px;
            padding: 4px 8px;
        }

        .param-value {
            min-width: 40px;
            font-size: 10px;
            color: var(--text-accent);
            text-align: center;
        }

        /* Gesture indicators */
        .gesture-hints {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            text-align: center;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .gesture-hints.show {
            opacity: 1;
        }

        /* Token analysis overlay */
        .token-overlay {
            position: absolute;
            top: 140px;
            right: 10px;
            width: 200px;
            max-height: calc(100vh - 300px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            z-index: 90;
            overflow-y: auto;
            transform: translateX(220px);
            transition: transform 0.3s ease;
        }

        .token-overlay.open {
            transform: translateX(0);
        }

        .token-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 10px;
        }

        .token-text {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .token-prob {
            color: var(--text-accent);
            font-weight: bold;
        }

        /* Comparison mode */
        .comparison-mode {
            position: absolute;
            top: 140px;
            left: 10px;
            width: 180px;
            height: 200px;
            background: var(--bg-secondary);
            border: 1px solid var(--research-highlight);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            z-index: 90;
            transform: translateX(-200px);
            transition: transform 0.3s ease;
        }

        .comparison-mode.open {
            transform: translateX(0);
        }

        .comparison-prompt {
            width: 100%;
            height: 60px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 10px;
            padding: 6px;
            resize: none;
            margin-bottom: 8px;
        }

        .compare-btn {
            width: 100%;
            height: 32px;
            background: var(--research-highlight);
            border: none;
            border-radius: 6px;
            color: white;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: var(--text-primary);
        }

        .loading-spinner {
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid var(--text-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* iPhone-specific optimizations */
        @media (max-width: 414px) and (orientation: portrait) {
            .research-hud {
                height: 100px;
                font-size: 10px;
            }
            
            .research-controls {
                height: 120px;
            }
            
            .token-overlay {
                width: 160px;
            }
            
            .comparison-mode {
                width: 150px;
                height: 180px;
            }
        }

        @media (orientation: landscape) {
            .research-hud {
                top: 5px;
                height: 80px;
                left: 200px;
                right: 200px;
            }
            
            .research-controls {
                bottom: 5px;
                height: 100px;
                left: 200px;
                right: 200px;
            }
            
            .token-overlay {
                top: 5px;
                right: 5px;
                max-height: calc(100vh - 120px);
            }
            
            .comparison-mode {
                top: 5px;
                left: 5px;
                height: calc(100vh - 120px);
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="babylonCanvas" aria-label="3D LLM introspection space"></canvas>
        
        <div class="loading-screen" id="loadingScreen">
            <div class="loading-spinner"></div>
            <div id="loadingText">Initializing WebLLM...</div>
        </div>
        
        <!-- Research HUD -->
        <div class="research-hud">
            <div class="hud-row">
                <div class="hud-metric">
                    <div class="hud-label">Entropy</div>
                    <div class="hud-value" id="entropyValue">0.00</div>
                </div>
                <div class="hud-metric">
                    <div class="hud-label">Top-K</div>
                    <div class="hud-value" id="topKValue">5</div>
                </div>
                <div class="hud-metric">
                    <div class="hud-label">Tokens</div>
                    <div class="hud-value" id="tokenCount">0</div>
                </div>
                <div class="hud-metric">
                    <div class="hud-label">Layer</div>
                    <div class="hud-value" id="currentLayer">-</div>
                </div>
            </div>
            <div class="hud-row">
                <div style="flex: 1;">
                    <div class="hud-label">Next Token Probability</div>
                    <div class="probability-bar">
                        <div class="probability-fill" id="probabilityFill" style="width: 0%"></div>
                        <div class="probability-text" id="probabilityText">-</div>
                    </div>
                </div>
            </div>
            <div class="hud-row">
                <div style="flex: 1; font-size: 10px; color: var(--text-secondary);">
                    <span id="currentToken">Ready</span> ‚Ä¢ <span id="modelStatus">No model loaded</span>
                </div>
            </div>
        </div>

        <!-- Research Controls -->
        <div class="research-controls">
            <div class="control-tabs">
                <div class="tab active" data-tab="generate">Generate</div>
                <div class="tab" data-tab="analyze">Analyze</div>
                <div class="tab" data-tab="model">Model</div>
            </div>
            
            <div class="tab-content active" id="generate-tab">
                <div class="param-row">
                    <input type="text" class="param-control" id="promptInput" 
                           placeholder="Enter research prompt..." value="The attention mechanism">
                </div>
                <div class="param-row">
                    <span class="param-label">Temp</span>
                    <input type="range" class="param-control" id="tempSlider" 
                           min="0.1" max="2.0" step="0.1" value="0.7">
                    <span class="param-value" id="tempValue">0.7</span>
                </div>
                <div class="param-row">
                    <button class="param-control" id="generateBtn" style="background: var(--research-highlight); color: white; border: none;">
                        Generate & Analyze
                    </button>
                </div>
            </div>
            
            <div class="tab-content" id="analyze-tab">
                <div class="param-row">
                    <span class="param-label">View</span>
                    <select class="param-control" id="visualMode">
                        <option value="embedding">Token Embeddings</option>
                        <option value="probability">Probability Space</option>
                        <option value="uncertainty">Uncertainty Map</option>
                        <option value="attention">Attention Flow</option>
                    </select>
                </div>
                <div class="param-row">
                    <span class="param-label">Layer</span>
                    <input type="range" class="param-control" id="layerSlider" 
                           min="0" max="11" step="1" value="6">
                    <span class="param-value" id="layerValue">6</span>
                </div>
                <div class="param-row">
                    <button class="param-control" id="exportBtn">Export Data</button>
                </div>
            </div>
            
            <div class="tab-content" id="model-tab">
                <div class="param-row">
                    <select class="param-control" id="modelSelect">
                        <option value="Phi-2-GGUF">Phi-2 (2.7B)</option>
                        <option value="TinyLlama-1.1B-Chat-v0.4-q4f16_1-1k">TinyLlama (1.1B)</option>
                    </select>
                </div>
                <div class="param-row">
                    <button class="param-control" id="loadModelBtn">Load Model</button>
                </div>
                <div class="param-row">
                    <button class="param-control" id="compareBtn">Compare Mode</button>
                </div>
            </div>
        </div>

        <!-- Token Analysis Overlay -->
        <div class="token-overlay" id="tokenOverlay">
            <h4 style="margin-bottom: 10px; font-size: 11px; color: var(--text-accent);">Token Analysis</h4>
            <div id="tokenList"></div>
        </div>

        <!-- Comparison Mode -->
        <div class="comparison-mode" id="comparisonMode">
            <h4 style="margin-bottom: 10px; font-size: 11px; color: var(--research-highlight);">Compare Prompts</h4>
            <textarea class="comparison-prompt" id="promptA" placeholder="Prompt A..."></textarea>
            <textarea class="comparison-prompt" id="promptB" placeholder="Prompt B..."></textarea>
            <button class="compare-btn" id="runComparisonBtn">Run Comparison</button>
            <div style="font-size: 9px; color: var(--text-secondary);">
                Swipe 3D space to switch between results
            </div>
        </div>

        <!-- Gesture Hints -->
        <div class="gesture-hints" id="gestureHints">
            <div>üëÜ Tap: Focus token</div>
            <div>‚úåÔ∏è Pinch: Zoom embedding space</div>
            <div>üëÜüëÜ Two-finger drag: Rotate view</div>
            <div>ü§è Long press: Analyze point</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.0.0/babylon.min.js"></script>
    <script type="module">
        import * as webllm from "https://esm.run/@mlc-ai/web-llm";

        class ResearchLLMIntrospector {
            constructor() {
                this.engine = null;
                this.currentModel = null;
                this.babylonEngine = null;
                this.scene = null;
                this.manifold = null;
                
                // Research data
                this.tokenData = [];
                this.probabilityHistory = [];
                this.comparisonData = { A: null, B: null };
                this.currentView = 'embedding';
                this.selectedLayer = 6;
                
                // Touch handling
                this.touches = new Map();
                this.lastTouchTime = 0;
                this.isGenerating = false;
                
                this.init();
            }

            async init() {
                try {
                    await this.initBabylon();
                    await this.initWebLLM();
                    this.setupControls();
                    this.setupGestures();
                    this.hideLoadingScreen();
                    this.showGestureHints();
                } catch (error) {
                    console.error("Initialization failed:", error);
                    document.getElementById('loadingText').textContent = `Error: ${error.message}`;
                }
            }

            async initBabylon() {
                const canvas = document.getElementById('babylonCanvas');
                this.babylonEngine = new BABYLON.Engine(canvas, true, {
                    antialias: false, // Better performance on mobile
                    stencil: false,
                    preserveDrawingBuffer: false
                });
                
                this.scene = new BABYLON.Scene(this.babylonEngine);
                this.scene.skipPointerMovePicking = true;
                
                // Camera optimized for research visualization
                const camera = new BABYLON.ArcRotateCamera("camera", 
                    -Math.PI / 2, Math.PI / 2.5, 8, BABYLON.Vector3.Zero(), this.scene);
                camera.attachControls(canvas, false); // We'll handle gestures manually
                camera.wheelPrecision = 50;
                
                // Lighting
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), this.scene);
                light.intensity = 0.8;
                
                this.createEmbeddingSpace();
                
                // Render loop
                this.babylonEngine.runRenderLoop(() => {
                    this.scene.render();
                });
                
                window.addEventListener('resize', () => {
                    this.babylonEngine.resize();
                });
            }

            createEmbeddingSpace() {
                // Create point cloud for token embeddings
                const positions = [];
                const colors = [];
                
                // Generate initial embedding space visualization
                for (let i = 0; i < 1000; i++) {
                    // Random positions in embedding space
                    positions.push(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                    
                    // Color based on semantic clusters
                    const cluster = Math.floor(Math.random() * 5);
                    const hue = cluster * 0.2;
                    colors.push(
                        Math.sin(hue * Math.PI * 2) * 0.5 + 0.5,
                        Math.sin((hue + 0.33) * Math.PI * 2) * 0.5 + 0.5,
                        Math.sin((hue + 0.66) * Math.PI * 2) * 0.5 + 0.5,
                        0.8
                    );
                }
                
                // Create point cloud mesh
                const pointCloud = new BABYLON.PointsCloudSystem("embeddings", 1000, this.scene);
                pointCloud.addPoints(1000, (particle, i) => {
                    particle.position.x = positions[i * 3];
                    particle.position.y = positions[i * 3 + 1];
                    particle.position.z = positions[i * 3 + 2];
                    particle.color.r = colors[i * 4];
                    particle.color.g = colors[i * 4 + 1];
                    particle.color.b = colors[i * 4 + 2];
                    particle.color.a = colors[i * 4 + 3];
                });
                
                pointCloud.buildMesh();
                this.manifold = pointCloud;
            }

            async initWebLLM() {
                this.updateLoadingText("Initializing WebLLM...");
                this.engine = new webllm.MLCEngine();
                this.updateModelStatus("WebLLM Ready");
            }

            setupControls() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.switchTab(tab.dataset.tab);
                    });
                });
                
                // Temperature slider
                document.getElementById('tempSlider').addEventListener('input', (e) => {
                    document.getElementById('tempValue').textContent = e.target.value;
                });
                
                // Layer slider
                document.getElementById('layerSlider').addEventListener('input', (e) => {
                    this.selectedLayer = parseInt(e.target.value);
                    document.getElementById('layerValue').textContent = e.target.value;
                    this.updateVisualization();
                });
                
                // Visual mode selector
                document.getElementById('visualMode').addEventListener('change', (e) => {
                    this.currentView = e.target.value;
                    this.updateVisualization();
                });
                
                // Model loading
                document.getElementById('loadModelBtn').addEventListener('click', () => {
                    this.loadModel();
                });
                
                // Generation
                document.getElementById('generateBtn').addEventListener('click', () => {
                    this.generateAndAnalyze();
                });
                
                // Export
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportData();
                });
                
                // Comparison mode
                document.getElementById('compareBtn').addEventListener('click', () => {
                    this.toggleComparisonMode();
                });
                
                document.getElementById('runComparisonBtn').addEventListener('click', () => {
                    this.runComparison();
                });
            }

            setupGestures() {
                const canvas = document.getElementById('babylonCanvas');
                
                // Touch start
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    Array.from(e.touches).forEach(touch => {
                        this.touches.set(touch.identifier, {
                            x: touch.clientX,
                            y: touch.clientY,
                            startTime: Date.now()
                        });
                    });
                    
                    if (e.touches.length === 1) {
                        this.handleSingleTouch(e.touches[0]);
                    }
                }, { passive: false });
                
                // Touch move
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    
                    if (e.touches.length === 2) {
                        this.handlePinchZoom(e.touches[0], e.touches[1]);
                    } else if (e.touches.length === 1) {
                        this.handleSingleTouchMove(e.touches[0]);
                    }
                }, { passive: false });
                
                // Touch end
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        const touchData = this.touches.get(touch.identifier);
                        if (touchData) {
                            const duration = Date.now() - touchData.startTime;
                            if (duration > 500) {
                                this.handleLongPress(touch);
                            }
                        }
                        this.touches.delete(touch.identifier);
                    });
                }, { passive: false });
                
                // Mouse fallback for development
                canvas.addEventListener('click', (e) => {
                    this.handleCanvasClick(e);
                });
            }

            handleSingleTouch(touch) {
                // Ray casting to find touched token
                const ray = this.getRayFromTouch(touch);
                const pickResult = this.scene.pick(touch.clientX, touch.clientY);
                
                if (pickResult.hit) {
                    this.focusToken(pickResult.pickedPoint);
                }
            }

            handleSingleTouchMove(touch) {
                const prevTouch = this.touches.get(touch.identifier);
                if (prevTouch) {
                    const deltaX = touch.clientX - prevTouch.x;
                    const deltaY = touch.clientY - prevTouch.y;
                    
                    // Rotate camera
                    const camera = this.scene.activeCamera;
                    camera.alpha += deltaX * 0.01;
                    camera.beta += deltaY * 0.01;
                    
                    // Update touch position
                    this.touches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY,
                        startTime: prevTouch.startTime
                    });
                }
            }

            handlePinchZoom(touch1, touch2) {
                // Calculate distance between touches
                const distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                if (this.lastPinchDistance) {
                    const scale = distance / this.lastPinchDistance;
                    const camera = this.scene.activeCamera;
                    camera.radius *= (2 - scale); // Invert for natural zoom
                    camera.radius = Math.max(2, Math.min(20, camera.radius));
                }
                
                this.lastPinchDistance = distance;
            }

            handleLongPress(touch) {
                // Analyze the point in detail
                const ray = this.getRayFromTouch(touch);
                const pickResult = this.scene.pick(touch.clientX, touch.clientY);
                
                if (pickResult.hit) {
                    this.analyzePoint(pickResult.pickedPoint);
                }
            }

            handleCanvasClick(e) {
                // Fallback for non-touch devices
                const pickResult = this.scene.pick(e.clientX, e.clientY);
                if (pickResult.hit) {
                    this.focusToken(pickResult.pickedPoint);
                }
            }

            getRayFromTouch(touch) {
                return this.scene.createPickingRay(
                    touch.clientX, 
                    touch.clientY, 
                    BABYLON.Matrix.Identity(), 
                    this.scene.activeCamera
                );
            }

            focusToken(point) {
                // Find nearest token to the picked point
                // This would map to actual token data in real implementation
                const tokenIndex = Math.floor(Math.random() * this.tokenData.length);
                if (this.tokenData[tokenIndex]) {
                    this.displayTokenAnalysis(this.tokenData[tokenIndex]);
                }
                
                // Show token overlay
                document.getElementById('tokenOverlay').classList.add('open');
                setTimeout(() => {
                    document.getElementById('tokenOverlay').classList.remove('open');
                }, 3000);
            }

            analyzePoint(point) {
                // Deep analysis of the selected point
                const analysis = {
                    embedding: [point.x, point.y, point.z],
                    semanticCluster: Math.floor(Math.random() * 5),
                    uncertainty: Math.random(),
                    attention: Math.random() * 0.8 + 0.1
                };
                
                console.log("Point Analysis:", analysis);
                // In real implementation, this would show detailed metrics
            }

            async loadModel() {
                try {
                    const modelId = document.getElementById('modelSelect').value;
                    this.updateModelStatus("Loading model...");
                    this.showLoadingScreen();
                    
                    await this.engine.reload(modelId);
                    this.currentModel = modelId;
                    this.updateModelStatus(`${modelId} loaded`);
                    this.hideLoadingScreen();
                    
                } catch (error) {
                    console.error("Model loading failed:", error);
                    this.updateModelStatus("Loading failed");
                    this.hideLoadingScreen();
                }
            }

            async generateAndAnalyze() {
                if (!this.currentModel || this.isGenerating) return;
                
                const prompt = document.getElementById('promptInput').value.trim();
                if (!prompt) return;
                
                this.isGenerating = true;
                this.tokenData = [];
                this.probabilityHistory = [];
                
                try {
                    const temperature = parseFloat(document.getElementById('tempSlider').value);
                    
                    const messages = [{ role: "user", content: prompt }];
                    const stream = await this.engine.chat.completions.create({
                        messages,
                        temperature,
                        max_tokens: 30,
                        stream: true,
                        logprobs: true, // Request probability data
                        top_logprobs: 10
                    });
                    
                    let tokenCount = 0;
                    for await (const chunk of stream) {
                        if (!this.isGenerating) break;
                        
                        const choice = chunk.choices[0];
                        if (choice?.delta?.content) {
                            tokenCount++;
                            
                            // Extract real probability data
                            const logprobs = choice.logprobs;
                            const tokenInfo = {
                                token: choice.delta.content,
                                position: tokenCount,
                                probability: logprobs ? Math.exp(logprobs.content[0].logprob) : 0.5,
                                topTokens: logprobs ? logprobs.content[0].top_logprobs : [],
                                timestamp: Date.now()
                            };
                            
                            this.tokenData.push(tokenInfo);
                            this.updateHUD(tokenInfo);
                            this.updateEmbeddingVisualization(tokenInfo);
                            
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                    
                } catch (error) {
                    console.error("Generation failed:", error);
                } finally {
                    this.isGenerating = false;
                }
            }

            updateHUD(tokenInfo) {
                // Calculate entropy from top tokens
                let entropy = 0;
                if (tokenInfo.topTokens && tokenInfo.topTokens.length > 0) {
                    tokenInfo.topTokens.forEach(token => {
                        const prob = Math.exp(token.logprob);
                        if (prob > 0) entropy -= prob * Math.log2(prob);
                    });
                }
                
                document.getElementById('entropyValue').textContent = entropy.toFixed(2);
                document.getElementById('topKValue').textContent = tokenInfo.topTokens?.length || 0;
                document.getElementById('tokenCount').textContent = this.tokenData.length;
                document.getElementById('currentLayer').textContent = this.selectedLayer;
                document.getElementById('currentToken').textContent = tokenInfo.token;
                
                // Update probability bar
                const probPercent = (tokenInfo.probability * 100).toFixed(1);
                document.getElementById('probabilityFill').style.width = `${tokenInfo.probability * 100}%`;
                document.getElementById('probabilityText').textContent = `${probPercent}%`;
            }

            updateEmbeddingVisualization(tokenInfo) {
                // Map token to 3D space based on semantic properties
                // This is simplified - real implementation would use actual embeddings
                const position = new BABYLON.Vector3(
                    (tokenInfo.token.charCodeAt(0) % 20 - 10) * 0.3,
                    (tokenInfo.probability - 0.5) * 10,
                    (tokenInfo.position % 20 - 10) * 0.3
                );
                
                // Create visualization marker
                const sphere = BABYLON.MeshBuilder.CreateSphere("token", {diameter: 0.2}, this.scene);
                sphere.position = position;
                
                // Color based on probability
                const material = new BABYLON.StandardMaterial("tokenMat", this.scene);
                material.emissiveColor = new BABYLON.Color3(
                    tokenInfo.probability,
                    1 - tokenInfo.probability,
                    0.5
                );
                sphere.material = material;
                
                // Animate appearance
                sphere.scaling = BABYLON.Vector3.Zero();
                BABYLON.Animation.CreateAndStartAnimation("tokenAppear", sphere, "scaling", 30, 10,
                    BABYLON.Vector3.Zero(), BABYLON.Vector3.One(), 0);
            }

            updateVisualization() {
                // Update 3D visualization based on current view mode
                switch (this.currentView) {
                    case 'embedding':
                        this.showEmbeddingSpace();
                        break;
                    case 'probability':
                        this.showProbabilitySpace();
                        break;
                    case 'uncertainty':
                        this.showUncertaintyMap();
                        break;
                    case 'attention':
                        this.showAttentionFlow();
                        break;
                }
            }

            showEmbeddingSpace() {
                // Visualize token embeddings in 3D space
                console.log("Showing embedding space");
            }

            showProbabilitySpace() {
                // Visualize probability distributions
                console.log("Showing probability space");
            }

            showUncertaintyMap() {
                // Visualize model uncertainty
                console.log("Showing uncertainty map");
            }

            showAttentionFlow() {
                // Visualize attention patterns
                console.log("Showing attention flow");
            }

            displayTokenAnalysis(tokenInfo) {
                const tokenList = document.getElementById('tokenList');
                tokenList.innerHTML = '';
                
                // Show current token details
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                tokenItem.innerHTML = `
                    <span class="token-text">${tokenInfo.token}</span>
                    <span class="token-prob">${(tokenInfo.probability * 100).toFixed(1)}%</span>
                `;
                tokenList.appendChild(tokenItem);
                
                // Show alternative tokens
                if (tokenInfo.topTokens) {
                    tokenInfo.topTokens.slice(1, 6).forEach(alt => {
                        const altItem = document.createElement('div');
                        altItem.className = 'token-item';
                        altItem.style.opacity = '0.6';
                        altItem.innerHTML = `
                            <span class="token-text">${alt.token}</span>
                            <span class="token-prob">${(Math.exp(alt.logprob) * 100).toFixed(1)}%</span>
                        `;
                        tokenList.appendChild(altItem);
                    });
                }
            }

            toggleComparisonMode() {
                const comparisonMode = document.getElementById('comparisonMode');
                comparisonMode.classList.toggle('open');
            }

            async runComparison() {
                const promptA = document.getElementById('promptA').value.trim();
                const promptB = document.getElementById('promptB').value.trim();
                
                if (!promptA || !promptB) return;
                
                console.log("Running comparison between:", promptA, "and", promptB);
                // Implement comparison logic
            }

            exportData() {
                const data = {
                    tokenData: this.tokenData,
                    probabilityHistory: this.probabilityHistory,
                    model: this.currentModel,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `llm-introspection-${Date.now()}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
            }

            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            }

            showGestureHints() {
                const hints = document.getElementById('gestureHints');
                hints.classList.add('show');
                setTimeout(() => {
                    hints.classList.remove('show');
                }, 3000);
            }

            updateLoadingText(text) {
                document.getElementById('loadingText').textContent = text;
            }

            updateModelStatus(status) {
                document.getElementById('modelStatus').textContent = status;
            }

            showLoadingScreen() {
                document.getElementById('loadingScreen').style.display = 'flex';
            }

            hideLoadingScreen() {
                document.getElementById('loadingScreen').style.display = 'none';
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new ResearchLLMIntrospector();
        });
    </script>
</body>
</html>

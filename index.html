<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="Professional LLM probability analysis with comprehensive error handling and real-time visualization">
    <meta name="keywords" content="LLM, probability, analysis, uncertainty, entropy, visualization">
    <meta name="author" content="LLM Research Tools">
    <title>LLM Probability Analyzer - Professional Interface</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß†</text></svg>">
</head>
<body>
    <!-- Application Container -->
    <div class="app-container" id="appContainer">
        <!-- Error Alert System -->
        <div class="error-alert" id="errorAlert" role="alert" aria-live="assertive">
            <span class="error-close" onclick="this.parentElement.classList.remove('show')" aria-label="Close error">&times;</span>
            <div id="errorMessage"></div>
        </div>

        <!-- Application Header -->
        <header class="header" role="banner">
            <div class="app-title">
                <h1>LLM Probability Analyzer</h1>
            </div>
            <div class="model-status">
                <span class="status-indicator" id="statusIndicator" aria-label="Model status" title="System status"></span>
                <span id="modelStatus">Initializing...</span>
            </div>
        </header>

        <!-- Configuration Controls -->
        <aside class="controls-panel" role="complementary" aria-label="Analysis configuration">
            <!-- Stage 1: Setup -->
            <section class="config-stage">
                <h3 class="stage-title">
                    <span class="stage-number">1</span>
                    Model Setup
                </h3>
                <div class="stage-content">
                    <select class="clean-select" id="modelSelect" aria-describedby="modelError">
                        <option value="">Choose model...</option>
                    </select>
                    <div class="validation-error" id="modelError" role="alert">Please select a model</div>
                    
                    <div class="button-group">
                        <button class="btn-primary" id="loadModelBtn">
                            <span>Load Model</span>
                            <div class="btn-progress" id="loadProgress" style="width: 0%;"></div>
                        </button>
                        <button class="btn-ghost" id="refreshModelsBtn" title="Refresh model list">
                            ‚Üª
                        </button>
                    </div>
                </div>
            </section>

            <!-- Stage 2: Configuration -->
            <section class="config-stage">
                <h3 class="stage-title">
                    <span class="stage-number">2</span>
                    Analysis Setup
                </h3>
                <div class="stage-content">
                    <div class="input-group">
                        <label class="clean-label">Input Text</label>
                        <textarea 
                            class="clean-textarea" 
                            id="promptInput" 
                            placeholder="Enter text for analysis..."
                            rows="3">The transformer architecture uses attention mechanisms to</textarea>
                        <div class="validation-error" id="promptError" role="alert">Text required</div>
                    </div>

                    <div class="params-grid">
                        <div class="param-item">
                            <label class="param-label">Temperature</label>
                            <div class="param-control">
                                <input type="range" class="clean-slider" id="tempSlider" 
                                       min="0.1" max="2.0" step="0.1" value="1.0">
                                <span class="param-value" id="tempValue">1.0</span>
                            </div>
                        </div>

                        <div class="param-item">
                            <label class="param-label">Max Tokens</label>
                            <div class="param-control">
                                <input type="number" class="clean-input" id="maxTokens" 
                                       min="5" max="50" value="20">
                            </div>
                        </div>

                        <div class="param-item">
                            <label class="param-label">Alternatives</label>
                            <div class="param-control">
                                <input type="range" class="clean-slider" id="topKSlider" 
                                       min="3" max="10" step="1" value="5">
                                <span class="param-value" id="topKValue">5</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Stage 3: Analysis -->
            <section class="config-stage">
                <h3 class="stage-title">
                    <span class="stage-number">3</span>
                    Generate
                </h3>
                <div class="stage-content">
                    <div class="action-group">
                        <button class="btn-primary btn-large" id="generateBtn" disabled>
                            <span>Analyze Probabilities</span>
                            <div class="btn-progress" id="generateProgress" style="width: 0%;"></div>
                        </button>
                        <button class="btn-stop" id="stopBtn" disabled>Stop</button>
                    </div>
                    
                    <div class="quick-options">
                        <label class="option-toggle">
                            <input type="checkbox" id="debugMode">
                            <span class="toggle-slider"></span>
                            Debug Log
                        </label>
                        <label class="option-toggle">
                            <input type="checkbox" id="autoExport">
                            <span class="toggle-slider"></span>
                            Auto Export
                        </label>
                    </div>
                </div>
            </section>
        </aside>

        <!-- Visualization Area -->
        <main class="visualization-area" role="main" aria-label="Probability visualization">
            <canvas id="probabilityCanvas" 
                    aria-label="Real-time probability distribution visualization"
                    role="img"></canvas>
            
            <!-- Visualization Overlay -->
            <div class="viz-overlay" id="vizOverlay" aria-live="polite">
                <div>Analysis: <span id="currentAnalysis">Token Probabilities</span></div>
                <div>Tokens: <span id="tokenCount">0</span></div>
                <div>Avg Entropy: <span id="avgEntropy">0.00</span></div>
                <div>Processing Rate: <span id="processingRate">0 tok/s</span></div>
            </div>
            
            <!-- Debug Log -->
            <div class="inference-log" id="inferenceLog" aria-live="polite">
                <div style="font-weight: bold; margin-bottom: 4px;">
                    Inference Debug Log
                    <button onclick="document.getElementById('logEntries').innerHTML=''" 
                            style="float: right; background: none; border: none; color: inherit; cursor: pointer;"
                            aria-label="Clear log">üóëÔ∏è</button>
                </div>
                <div id="logEntries"></div>
            </div>
        </main>

        <!-- Results Panel -->
        <section class="results-panel" role="complementary" aria-label="Analysis results">
            <div class="results-header">
                <h3>Analysis Results</h3>
                <div class="results-nav">
                    <button class="nav-tab active" data-tab="live" role="tab">Live</button>
                    <button class="nav-tab" data-tab="tokens" role="tab">Tokens</button>
                    <button class="nav-tab" data-tab="stats" role="tab">Stats</button>
                    <button class="nav-tab" data-tab="export" role="tab">Export</button>
                </div>
            </div>

            <!-- Live Metrics -->
            <div class="tab-content active" id="live-content" role="tabpanel">
                <div class="metrics-overview">
                    <div class="metric-item">
                        <div class="metric-value" id="currentEntropy">0.00</div>
                        <div class="metric-name">Entropy</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="currentConfidence">0%</div>
                        <div class="metric-name">Confidence</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="currentSurprisal">0.0</div>
                        <div class="metric-name">Surprisal</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="currentPerplexity">0.0</div>
                        <div class="metric-name">Perplexity</div>
                    </div>
                </div>
                
                <div class="current-analysis" id="probabilityDetails">
                    <div class="analysis-placeholder">
                        Ready to analyze probabilities
                    </div>
                </div>
            </div>

            <!-- Token Sequence -->
            <div class="tab-content" id="tokens-content" role="tabpanel">
                <div class="token-inspector">
                    <div class="token-sequence">
                        <div class="token-stream" id="tokenStream" role="list"></div>
                        <div class="sequence-legend">
                            <span class="legend-item high">High uncertainty</span>
                            <span class="legend-item medium">Medium uncertainty</span>
                            <span class="legend-item low">Low uncertainty</span>
                        </div>
                    </div>
                    <div class="token-details" id="alternativeTokens">
                        <div class="details-placeholder">Click a token to inspect alternatives</div>
                    </div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="tab-content" id="stats-content" role="tabpanel">
                <div class="stats-container">
                    <div class="stats-section">
                        <h4>Statistical Summary</h4>
                        <div id="statsResults">
                            Generate tokens to see statistical analysis
                        </div>
                    </div>
                    <div class="stats-section">
                        <h4>Performance</h4>
                        <div id="perfResults">
                            <div class="perf-metric">
                                <span>Generation Time</span>
                                <span id="generationTime">-</span>
                            </div>
                            <div class="perf-metric">
                                <span>Tokens/Second</span>
                                <span id="tokensPerSecond">-</span>
                            </div>
                            <div class="perf-metric">
                                <span>Processing Rate</span>
                                <span id="processingRate">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Export -->
            <div class="tab-content" id="export-content" role="tabpanel">
                <div class="export-section">
                    <h4>Export Data</h4>
                    <p class="export-description">
                        Export analysis results with complete probability data, statistics, and reproducibility metadata.
                    </p>
                    <div class="export-actions">
                        <button class="btn-primary" id="exportJsonBtn">
                            Export JSON
                        </button>
                        <button class="btn-secondary" id="exportCsvBtn">
                            Export CSV
                        </button>
                        <button class="btn-ghost" id="shareConfigBtn">
                            Share Config
                        </button>
                    </div>
                    <div class="export-status" id="lastExport">
                        No exports yet
                    </div>
                </div>
            </div>
        </section>

        <!-- Status Bar -->
        <footer class="status-bar" role="contentinfo">
            <div class="session-info">
                <span class="info-item">Session: <span id="experimentId">-</span></span>
                <span class="info-item">Model: <span id="currentModelName">None</span></span>
                <span class="info-item">Tokens: <span id="totalTokens">0</span></span>
            </div>
            <div class="status-info">
                <span id="lastExport">Ready</span>
            </div>
        </footer>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen" role="dialog" aria-modal="true" aria-labelledby="loadingText">
        <div class="loading-spinner" aria-hidden="true"></div>
        <div class="loading-text" id="loadingText">Initializing WebLLM...</div>
        <div class="loading-details" id="loadingDetails">Setting up analysis environment</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgressBar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
    </div>

    <!-- Application JavaScript -->
    <script type="module">
        // Import WebLLM with fallback error handling
        let webllm;
        try {
            webllm = await import("https://esm.run/@mlc-ai/web-llm");
        } catch (importError) {
            console.error('Failed to import WebLLM:', importError);
            document.getElementById('loadingText').textContent = 'Failed to load WebLLM library';
            document.getElementById('loadingDetails').textContent = 'Please check your internet connection and try refreshing the page';
            throw new Error('WebLLM import failed: ' + importError.message);
        }

        /**
         * Application Configuration
         */
        const APP_CONFIG = {
            version: '2.1.0',
            maxRetries: 3,
            retryDelay: 1000,
            autoSaveInterval: 30000,
            performanceTracking: true,
            errorReporting: true,
            maxTokenHistory: 100,
            updateThrottleMs: 150,
            modelTimeoutMs: 300000, // 5 minutes
            defaultModels: [
                'TinyLlama-1.1B-Chat-v0.4-q4f16_1',
                'Phi-2-q4f16_1',
                'gemma-2b-it-q4f16_1'
            ]
        };

        /**
         * Enhanced Error Handler with categorization and reporting
         */
        class ErrorHandler {
            static errorCount = 0;
            static errorHistory = [];

            static showError(message, details = null, category = 'general') {
                this.errorCount++;
                console.error(`[${category}] Application Error:`, message, details);
                
                // Store error for reporting
                const errorRecord = {
                    timestamp: new Date().toISOString(),
                    category,
                    message,
                    details: details || 'No details provided',
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                this.errorHistory.push(errorRecord);
                
                // Show user-friendly error
                const alertEl = document.getElementById('errorAlert');
                const messageEl = document.getElementById('errorMessage');
                
                if (alertEl && messageEl) {
                    messageEl.innerHTML = `<strong>${category}:</strong> ${message}`;
                    if (details && typeof details === 'string') {
                        messageEl.innerHTML += `<br><small>Details: ${details}</small>`;
                    }
                    
                    alertEl.classList.add('show');
                    
                    // Auto-hide after 8 seconds
                    setTimeout(() => {
                        alertEl.classList.remove('show');
                    }, 8000);
                }
            }

            static logError(context, error) {
                const timestamp = new Date().toISOString();
                const errorInfo = {
                    timestamp,
                    context,
                    error: error.message || error.toString(),
                    stack: error.stack || 'No stack trace available'
                };
                
                console.error(`[${timestamp}] ${context}:`, error);
                return errorInfo;
            }

            static getErrorReport() {
                return {
                    totalErrors: this.errorCount,
                    errors: this.errorHistory.slice(-10), // Last 10 errors
                    appVersion: APP_CONFIG.version,
                    timestamp: new Date().toISOString()
                };
            }

            static clearErrors() {
                this.errorCount = 0;
                this.errorHistory = [];
            }
        }

        /**
         * Enhanced Input Validator with comprehensive checks
         */
        class InputValidator {
            static validationRules = {
                prompt: {
                    minLength: 1,
                    maxLength: 1000,
                    pattern: null
                },
                temperature: {
                    min: 0.1,
                    max: 2.0,
                    step: 0.1
                },
                maxTokens: {
                    min: 5,
                    max: 50,
                    step: 1
                },
                topK: {
                    min: 3,
                    max: 10,
                    step: 1
                }
            };

            static validatePrompt(prompt) {
                const trimmed = prompt.trim();
                const rules = this.validationRules.prompt;
                
                if (!trimmed) {
                    throw new Error('Prompt cannot be empty');
                }
                if (trimmed.length < rules.minLength) {
                    throw new Error(`Prompt must be at least ${rules.minLength} characters`);
                }
                if (trimmed.length > rules.maxLength) {
                    throw new Error(`Prompt too long (max ${rules.maxLength} characters)`);
                }
                return trimmed;
            }

            static validateTemperature(temp) {
                const value = parseFloat(temp);
                const rules = this.validationRules.temperature;
                
                if (isNaN(value)) {
                    throw new Error('Temperature must be a valid number');
                }
                if (value < rules.min || value > rules.max) {
                    throw new Error(`Temperature must be between ${rules.min} and ${rules.max}`);
                }
                return Math.round(value * 10) / 10; // Round to 1 decimal place
            }

            static validateMaxTokens(tokens) {
                const value = parseInt(tokens);
                const rules = this.validationRules.maxTokens;
                
                if (isNaN(value)) {
                    throw new Error('Max tokens must be a valid number');
                }
                if (value < rules.min || value > rules.max) {
                    throw new Error(`Max tokens must be between ${rules.min} and ${rules.max}`);
                }
                return value;
            }

            static validateTopK(topK) {
                const value = parseInt(topK);
                const rules = this.validationRules.topK;
                
                if (isNaN(value)) {
                    throw new Error('Top-K must be a valid number');
                }
                if (value < rules.min || value > rules.max) {
                    throw new Error(`Top-K must be between ${rules.min} and ${rules.max}`);
                }
                return value;
            }

            static showValidationError(fieldId, message) {
                const field = document.getElementById(fieldId);
                const errorEl = document.getElementById(fieldId.replace(/Input|Slider/, 'Error'));
                
                if (field && errorEl) {
                    field.classList.add('error');
                    errorEl.textContent = message;
                    errorEl.style.display = 'block';
                    
                    // Add ARIA attributes for accessibility
                    field.setAttribute('aria-invalid', 'true');
                    field.setAttribute('aria-describedby', errorEl.id);
                }
            }

            static clearValidationError(fieldId) {
                const field = document.getElementById(fieldId);
                const errorEl = document.getElementById(fieldId.replace(/Input|Slider/, 'Error'));
                
                if (field && errorEl) {
                    field.classList.remove('error');
                    errorEl.style.display = 'none';
                    field.removeAttribute('aria-invalid');
                }
            }

            static clearAllValidationErrors() {
                const errorElements = document.querySelectorAll('.validation-error');
                const fieldElements = document.querySelectorAll('.form-input, .slider');
                
                errorElements.forEach(el => el.style.display = 'none');
                fieldElements.forEach(el => {
                    el.classList.remove('error');
                    el.removeAttribute('aria-invalid');
                });
            }

            static validateAll() {
                this.clearAllValidationErrors();
                const errors = [];

                try {
                    this.validatePrompt(document.getElementById('promptInput').value);
                } catch (error) {
                    this.showValidationError('promptInput', error.message);
                    errors.push(error.message);
                }

                try {
                    this.validateTemperature(document.getElementById('tempSlider').value);
                } catch (error) {
                    this.showValidationError('tempSlider', error.message);
                    errors.push(error.message);
                }

                try {
                    this.validateMaxTokens(document.getElementById('maxTokens').value);
                } catch (error) {
                    this.showValidationError('maxTokens', error.message);
                    errors.push(error.message);
                }

                try {
                    this.validateTopK(document.getElementById('topKValue').textContent);
                } catch (error) {
                    this.showValidationError('topKSlider', error.message);
                    errors.push(error.message);
                }

                return errors.length === 0;
            }
        }

        /**
         * Performance Monitor for tracking app performance
         */
        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    generationStartTime: null,
                    generationEndTime: null,
                    tokenTimes: [],
                    errorCount: 0,
                    totalTokens: 0
                };
            }

            startGeneration() {
                this.metrics.generationStartTime = performance.now();
                this.metrics.tokenTimes = [];
                this.metrics.totalTokens = 0;
            }

            recordToken() {
                if (this.metrics.generationStartTime) {
                    this.metrics.tokenTimes.push(performance.now());
                    this.metrics.totalTokens++;
                }
            }

            endGeneration() {
                this.metrics.generationEndTime = performance.now();
                this.updateUI();
            }

            updateUI() {
                if (!this.metrics.generationStartTime || !this.metrics.generationEndTime) return;

                const totalTime = this.metrics.generationEndTime - this.metrics.generationStartTime;
                const tokensPerSecond = this.metrics.totalTokens / (totalTime / 1000);
                const avgProcessingTime = totalTime / this.metrics.totalTokens;

                const updateElement = (id, value) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                };

                updateElement('generationTime', `${(totalTime / 1000).toFixed(2)}s`);
                updateElement('tokensPerSecond', `${tokensPerSecond.toFixed(1)}`);
                updateElement('avgProcessingTime', `${avgProcessingTime.toFixed(1)}ms`);
                updateElement('processingRate', `${tokensPerSecond.toFixed(1)} tok/s`);
            }

            getMetrics() {
                return { ...this.metrics };
            }
        }

        /**
         * Enhanced inference logger with filtering and search
         */
        class InferenceLogger {
            constructor() {
                this.logs = [];
                this.maxLogs = 100;
                this.enabled = false;
                this.filters = new Set(['info', 'success', 'warning', 'error']);
            }

            enable() {
                this.enabled = true;
                const logContainer = document.getElementById('inferenceLog');
                if (logContainer) {
                    logContainer.classList.add('show');
                }
            }

            disable() {
                this.enabled = false;
                const logContainer = document.getElementById('inferenceLog');
                if (logContainer) {
                    logContainer.classList.remove('show');
                }
            }

            log(message, type = 'info', data = null) {
                if (!this.enabled) return;

                const timestamp = new Date().toLocaleTimeString();
                const logEntry = {
                    id: Date.now() + Math.random(),
                    timestamp,
                    message,
                    type,
                    data
                };

                this.logs.push(logEntry);
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }

                this.updateUI();
            }

            updateUI() {
                const container = document.getElementById('logEntries');
                if (!container) return;

                const filteredLogs = this.logs
                    .filter(log => this.filters.has(log.type))
                    .slice(-30); // Show last 30 entries

                container.innerHTML = filteredLogs
                    .map(log => `<div class="log-entry ${log.type}" data-id="${log.id}">
                        [${log.timestamp}] ${log.message}
                        ${log.data ? `<br><small style="opacity: 0.7;">${JSON.stringify(log.data).substring(0, 100)}</small>` : ''}
                    </div>`)
                    .join('');

                // Auto-scroll to bottom
                container.scrollTop = container.scrollHeight;
            }

            clear() {
                this.logs = [];
                this.updateUI();
            }

            export() {
                return {
                    logs: this.logs,
                    timestamp: new Date().toISOString(),
                    enabled: this.enabled
                };
            }
        }

        /**
         * Enhanced Statistical Analysis with additional metrics
         */
        class StatisticalAnalysis {
            static calculateEntropy(probabilities) {
                if (!Array.isArray(probabilities) || probabilities.length === 0) {
                    return 0;
                }

                const validProbs = probabilities.filter(p => 
                    typeof p === 'number' && !isNaN(p) && p > 0 && p <= 1
                );

                if (validProbs.length === 0) {
                    return 0;
                }

                // Normalize probabilities to ensure they sum to 1
                const sum = validProbs.reduce((acc, p) => acc + p, 0);
                const normalizedProbs = validProbs.map(p => p / sum);

                return -normalizedProbs.reduce((sum, p) => {
                    return sum + p * Math.log2(p);
                }, 0);
            }

            static calculateSurprisal(probability) {
                if (typeof probability !== 'number' || isNaN(probability) || probability <= 0) {
                    return 0;
                }
                return -Math.log2(Math.max(probability, 1e-10));
            }

            static calculatePerplexity(probabilities) {
                const entropy = this.calculateEntropy(probabilities);
                return Math.pow(2, entropy);
            }

            static calculateKLDivergence(p, q) {
                if (!Array.isArray(p) || !Array.isArray(q) || p.length !== q.length) {
                    return 0;
                }

                return p.reduce((sum, pi, i) => {
                    const qi = q[i];
                    if (pi > 0 && qi > 0) {
                        return sum + pi * Math.log2(pi / qi);
                    }
                    return sum;
                }, 0);
            }

            static classifyUncertainty(entropy) {
                if (typeof entropy !== 'number' || isNaN(entropy)) {
                    return 'low';
                }
                
                if (entropy > 3.0) return 'high';
                if (entropy > 1.5) return 'medium';
                return 'low';
            }

            static calculateStatistics(values) {
                if (!Array.isArray(values) || values.length === 0) {
                    return null;
                }

                const validValues = values.filter(v => 
                    typeof v === 'number' && !isNaN(v) && isFinite(v)
                );

                if (validValues.length === 0) {
                    return null;
                }
                
                const sorted = [...validValues].sort((a, b) => a - b);
                const n = validValues.length;
                const mean = validValues.reduce((a, b) => a + b) / n;
                const variance = validValues.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / n;
                const std = Math.sqrt(variance);
                
                // Additional statistics
                const skewness = validValues.reduce((sum, x) => sum + Math.pow((x - mean) / std, 3), 0) / n;
                const kurtosis = validValues.reduce((sum, x) => sum + Math.pow((x - mean) / std, 4), 0) / n - 3;
                
                return {
                    count: n,
                    mean,
                    median: sorted[Math.floor(n / 2)],
                    std,
                    variance,
                    min: sorted[0],
                    max: sorted[n - 1],
                    q25: sorted[Math.floor(n * 0.25)],
                    q75: sorted[Math.floor(n * 0.75)],
                    skewness,
                    kurtosis,
                    range: sorted[n - 1] - sorted[0]
                };
            }
        }

        /**
         * Enhanced Probability Visualizer with more visualization options
         */
        class ProbabilityVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    throw new Error('Canvas element not found');
                }
                
                this.ctx = this.canvas.getContext('2d');
                this.tokens = [];
                this.maxTokens = APP_CONFIG.maxTokenHistory;
                this.animationFrame = null;
                this.lastUpdateTime = 0;
                this.theme = 'dark';
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                if (!this.canvas) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                this.redraw();
            }

            addToken(tokenData) {
                if (!tokenData || typeof tokenData !== 'object') {
                    console.warn('Invalid token data provided to visualizer');
                    return;
                }

                this.tokens.push({
                    ...tokenData,
                    addedAt: performance.now()
                });
                
                if (this.tokens.length > this.maxTokens) {
                    this.tokens.shift();
                }
                
                // Throttle redraws for better performance
                const now = performance.now();
                if (now - this.lastUpdateTime > APP_CONFIG.updateThrottleMs) {
                    this.scheduleRedraw();
                    this.lastUpdateTime = now;
                }
            }

            scheduleRedraw() {
                if (!this.animationFrame) {
                    this.animationFrame = requestAnimationFrame(() => {
                        this.redraw();
                        this.animationFrame = null;
                    });
                }
            }

            redraw() {
                if (!this.ctx) return;
                
                const rect = this.canvas.getBoundingClientRect();
                this.ctx.clearRect(0, 0, rect.width, rect.height);
                
                if (this.tokens.length === 0) {
                    this.drawPlaceholder();
                    return;
                }

                try {
                    this.drawBackground();
                    this.drawEntropyGraph();
                    this.drawProbabilityDistribution();
                    this.drawStats();
                } catch (error) {
                    console.error('Visualization error:', error);
                    this.drawErrorMessage(error.message);
                }
            }

            drawBackground() {
                const rect = this.canvas.getBoundingClientRect();
                const gradient = this.ctx.createLinearGradient(0, 0, 0, rect.height);
                gradient.addColorStop(0, 'rgba(10, 15, 30, 0.9)');
                gradient.addColorStop(1, 'rgba(5, 10, 20, 0.9)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, rect.width, rect.height);
            }

            drawPlaceholder() {
                const rect = this.canvas.getBoundingClientRect();
                this.ctx.fillStyle = 'rgba(123, 179, 255, 0.3)';
                this.ctx.font = '14px var(--font-primary)';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('Generate tokens to see probability analysis', rect.width / 2, rect.height / 2);
            }

            drawErrorMessage(message) {
                const rect = this.canvas.getBoundingClientRect();
                this.ctx.fillStyle = 'rgba(229, 85, 85, 0.7)';
                this.ctx.font = '12px var(--font-primary)';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(`Visualization error: ${message}`, rect.width / 2, rect.height / 2);
            }

            drawEntropyGraph() {
                const rect = this.canvas.getBoundingClientRect();
                const margin = 40;
                const graphWidth = rect.width - 2 * margin;
                const graphHeight = (rect.height * 0.4) - margin;
                
                if (this.tokens.length < 2) return;

                const validTokens = this.tokens.filter(t => 
                    t.entropy !== undefined && 
                    typeof t.entropy === 'number' && 
                    !isNaN(t.entropy) && 
                    isFinite(t.entropy)
                );

                if (validTokens.length < 2) return;

                // Draw grid
                this.drawGrid(margin, margin, graphWidth, graphHeight);

                // Draw entropy line
                this.ctx.strokeStyle = '#7bb3ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const entropies = validTokens.map(t => t.entropy);
                const maxEntropy = Math.max(...entropies);
                const minEntropy = Math.min(...entropies);
                const entropyRange = maxEntropy - minEntropy || 1;

                validTokens.forEach((token, index) => {
                    const x = margin + (index / (validTokens.length - 1)) * graphWidth;
                    const y = margin + graphHeight - ((token.entropy - minEntropy) / entropyRange) * graphHeight;
                    
                    if (index === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                    
                    // Add points
                    this.ctx.fillStyle = this.getUncertaintyColor(token.uncertainty);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.beginPath();
                });
                
                this.ctx.stroke();

                // Labels
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '10px var(--font-mono)';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('Entropy over time', margin, margin - 20);
                
                // Y-axis labels
                this.ctx.textAlign = 'right';
                this.ctx.fillText(maxEntropy.toFixed(1), margin - 5, margin);
                this.ctx.fillText(minEntropy.toFixed(1), margin - 5, margin + graphHeight);
            }

            drawGrid(x, y, width, height) {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                // Horizontal lines
                for (let i = 0; i <= 4; i++) {
                    const yPos = y + (i * height / 4);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, yPos);
                    this.ctx.lineTo(x + width, yPos);
                    this.ctx.stroke();
                }
                
                // Vertical lines
                for (let i = 0; i <= 4; i++) {
                    const xPos = x + (i * width / 4);
                    this.ctx.beginPath();
                    this.ctx.moveTo(xPos, y);
                    this.ctx.lineTo(xPos, y + height);
                    this.ctx.stroke();
                }
            }

            drawProbabilityDistribution() {
                const rect = this.canvas.getBoundingClientRect();
                const margin = 40;
                const startY = rect.height * 0.6;
                const graphWidth = rect.width - 2 * margin;
                const graphHeight = (rect.height * 0.35) - margin;
                
                if (this.tokens.length === 0) return;

                const currentToken = this.tokens[this.tokens.length - 1];
                if (!currentToken.alternatives || !Array.isArray(currentToken.alternatives) || currentToken.alternatives.length === 0) {
                    return;
                }

                const validAlternatives = currentToken.alternatives.filter(alt => 
                    alt && typeof alt === 'object' && typeof alt.logprob === 'number' && !isNaN(alt.logprob)
                );

                if (validAlternatives.length === 0) return;

                const barWidth = graphWidth / validAlternatives.length;
                
                validAlternatives.forEach((alt, index) => {
                    const prob = Math.exp(alt.logprob);
                    if (isNaN(prob) || !isFinite(prob)) return;
                    
                    const barHeight = prob * graphHeight;
                    const x = margin + index * barWidth;
                    const y = startY + graphHeight - barHeight;
                    
                    // Gradient fill
                    const gradient = this.ctx.createLinearGradient(0, y, 0, y + barHeight);
                    const alpha = Math.max(0.3, Math.min(1.0, 0.3 + prob * 0.7));
                    gradient.addColorStop(0, `rgba(123, 179, 255, ${alpha})`);
                    gradient.addColorStop(1, `rgba(123, 179, 255, ${alpha * 0.6})`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
                    
                    // Probability text
                    if (prob > 0.05) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.font = '9px var(--font-mono)';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'bottom';
                        this.ctx.fillText(`${(prob * 100).toFixed(0)}%`, x + barWidth / 2, y - 2);
                    }
                    
                    // Token text
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.textBaseline = 'top';
                    const tokenText = (alt.token || '').toString().substring(0, 8);
                    this.ctx.fillText(tokenText, x + barWidth / 2, startY + graphHeight + 5);
                });

                // Label
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '10px var(--font-mono)';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('Current token alternatives', margin, startY - 15);
            }

            drawStats() {
                if (this.tokens.length === 0) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const currentToken = this.tokens[this.tokens.length - 1];
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '9px var(--font-mono)';
                this.ctx.textAlign = 'right';
                this.ctx.textBaseline = 'top';
                
                const stats = [
                    `Token: "${currentToken.token || 'N/A'}"`,
                    `Entropy: ${(currentToken.entropy || 0).toFixed(2)}`,
                    `Confidence: ${((currentToken.probability || 0) * 100).toFixed(1)}%`,
                    `Position: ${currentToken.position || 0}`
                ];
                
                stats.forEach((stat, index) => {
                    this.ctx.fillText(stat, rect.width - 10, 10 + (index * 12));
                });
            }

            getUncertaintyColor(uncertainty) {
                switch (uncertainty) {
                    case 'high': return '#ff6b6b';
                    case 'medium': return '#ffa500';
                    case 'low': return '#4ecdc4';
                    default: return '#7bb3ff';
                }
            }

            clear() {
                this.tokens = [];
                this.redraw();
            }

            destroy() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                window.removeEventListener('resize', this.resizeCanvas);
            }

            exportImage() {
                return this.canvas.toDataURL('image/png');
            }
        }

        /**
         * Configuration Manager for app settings
         */
        class ConfigurationManager {
            constructor() {
                this.config = this.loadConfig();
            }

            loadConfig() {
                try {
                    const saved = localStorage.getItem('llm-analyzer-config');
                    return saved ? { ...APP_CONFIG, ...JSON.parse(saved) } : APP_CONFIG;
                } catch (error) {
                    console.warn('Failed to load saved configuration:', error);
                    return APP_CONFIG;
                }
            }

            saveConfig() {
                try {
                    localStorage.setItem('llm-analyzer-config', JSON.stringify(this.config));
                } catch (error) {
                    console.warn('Failed to save configuration:', error);
                }
            }

            get(key) {
                return this.config[key];
            }

            set(key, value) {
                this.config[key] = value;
                this.saveConfig();
            }

            getAll() {
                return { ...this.config };
            }

            reset() {
                this.config = { ...APP_CONFIG };
                this.saveConfig();
            }

            exportConfig() {
                return {
                    config: this.config,
                    timestamp: new Date().toISOString(),
                    version: APP_CONFIG.version
                };
            }

            importConfig(configData) {
                if (configData && configData.config) {
                    this.config = { ...APP_CONFIG, ...configData.config };
                    this.saveConfig();
                    return true;
                }
                return false;
            }
        }

        /**
         * Main Application Class - Enhanced and Comprehensive
         */
        class RobustLLMAnalyzer {
            constructor() {
                // Core properties
                this.engine = null;
                this.currentModel = null;
                this.isGenerating = false;
                this.isLoading = false;
                this.tokenData = [];
                this.experimentId = this.generateExperimentId();
                
                // Enhanced components
                this.visualizer = null;
                this.logger = new InferenceLogger();
                this.performanceMonitor = new PerformanceMonitor();
                this.configManager = new ConfigurationManager();
                
                // Control flow
                this.abortController = null;
                this.generationErrors = [];
                this.retryCount = 0;
                this.lastUpdate = 0;
                
                // Auto-save timer
                this.autoSaveTimer = null;
                
                this.init();
            }

            generateExperimentId() {
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 5);
                return `sess_${timestamp}_${random}`;
            }

            async init() {
                try {
                    this.updateLoadingText('Initializing application...', 'Setting up components');
                    this.updateLoadingProgress(10);
                    
                    // Initialize visualizer
                    this.visualizer = new ProbabilityVisualizer('probabilityCanvas');
                    this.updateLoadingProgress(20);
                    
                    // Initialize WebLLM engine
                    this.updateLoadingText('Loading WebLLM engine...', 'This may take a moment');
                    this.engine = new webllm.MLCEngine();
                    this.updateLoadingProgress(40);
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    this.updateLoadingProgress(60);
                    
                    // Initialize UI
                    this.updateUI();
                    this.updateLoadingProgress(80);
                    
                    // Load available models
                    this.updateLoadingText('Loading model catalog...', 'Checking available models');
                    await this.refreshAvailableModels();
                    this.updateLoadingProgress(90);
                    
                    // Final setup
                    this.setupAutoSave();
                    document.getElementById('experimentId').textContent = this.experimentId;
                    this.updateLoadingProgress(100);
                    
                    // Hide loading screen
                    setTimeout(() => {
                        this.hideLoadingScreen();
                        this.updateModelStatus('Application ready - select a model to begin');
                        this.logger.log('Application initialized successfully', 'success');
                    }, 500);
                    
                } catch (error) {
                    const errorInfo = ErrorHandler.logError('Initialization', error);
                    this.updateLoadingText('Initialization failed', error.message);
                    ErrorHandler.showError('Failed to initialize application', error.message, 'initialization');
                    this.updateModelStatus('Initialization failed', 'error');
                }
            }

            setupEventListeners() {
                // Model management
                document.getElementById('loadModelBtn')?.addEventListener('click', () => {
                    this.loadModel();
                });

                document.getElementById('refreshModelsBtn')?.addEventListener('click', () => {
                    this.refreshAvailableModels();
                });

                // Generation controls
                document.getElementById('generateBtn')?.addEventListener('click', () => {
                    this.generateAndAnalyze();
                });

                document.getElementById('stopBtn')?.addEventListener('click', () => {
                    this.stopGeneration();
                });

                // Tab switching
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.switchTab(tab.dataset.tab);
                    });
                });

                // Slider updates with live feedback
                const tempSlider = document.getElementById('tempSlider');
                const tempValue = document.getElementById('tempValue');
                
                tempSlider?.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (tempValue) tempValue.textContent = value;
                    InputValidator.clearValidationError('tempSlider');
                });

                const topKSlider = document.getElementById('topKSlider');
                const topKValue = document.getElementById('topKValue');
                
                topKSlider?.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    if (topKValue) topKValue.textContent = value;
                    InputValidator.clearValidationError('topKSlider');
                });

                // Input validation with debouncing
                let validationTimeout;
                const debounceValidation = (fieldId) => {
                    clearTimeout(validationTimeout);
                    validationTimeout = setTimeout(() => {
                        InputValidator.clearValidationError(fieldId);
                    }, 500);
                };

                document.getElementById('promptInput')?.addEventListener('input', () => {
                    debounceValidation('promptInput');
                });

                document.getElementById('maxTokens')?.addEventListener('input', () => {
                    debounceValidation('maxTokens');
                });

                // Advanced options
                document.getElementById('debugMode')?.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.logger.enable();
                        this.logger.log('Debug mode enabled', 'info');
                    } else {
                        this.logger.disable();
                    }
                });

                document.getElementById('autoExport')?.addEventListener('change', (e) => {
                    this.configManager.set('autoExport', e.target.checked);
                    this.logger.log(`Auto-export ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
                });

                document.getElementById('verboseMode')?.addEventListener('change', (e) => {
                    this.configManager.set('verboseMode', e.target.checked);
                });

                // Export functionality
                document.getElementById('exportJsonBtn')?.addEventListener('click', () => {
                    this.exportData('json');
                });

                document.getElementById('exportCsvBtn')?.addEventListener('click', () => {
                    this.exportData('csv');
                });

                document.getElementById('shareConfigBtn')?.addEventListener('click', () => {
                    this.shareConfiguration();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 'Enter':
                                e.preventDefault();
                                if (!this.isGenerating && this.currentModel) {
                                    this.generateAndAnalyze();
                                }
                                break;
                            case 's':
                                e.preventDefault();
                                this.exportData('json');
                                break;
                            case 'e':
                                e.preventDefault();
                                this.exportData('csv');
                                break;
                        }
                    }
                });

                // Cleanup on page unload
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });

                // Handle visibility change for performance
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseUpdates();
                    } else {
                        this.resumeUpdates();
                    }
                });
            }

            setupAutoSave() {
                if (this.configManager.get('autoSaveInterval') > 0) {
                    this.autoSaveTimer = setInterval(() => {
                        if (this.tokenData.length > 0) {
                            this.autoSaveSession();
                        }
                    }, this.configManager.get('autoSaveInterval'));
                }
            }

            autoSaveSession() {
                try {
                    const sessionData = {
                        experimentId: this.experimentId,
                        timestamp: new Date().toISOString(),
                        tokenData: this.tokenData.slice(-20), // Save last 20 tokens
                        config: this.getCurrentConfiguration()
                    };
                    
                    localStorage.setItem('llm-analyzer-session', JSON.stringify(sessionData));
                    this.logger.log('Session auto-saved', 'info');
                } catch (error) {
                    console.warn('Auto-save failed:', error);
                }
            }

            async refreshAvailableModels() {
                try {
                    this.updateModelStatus('Loading model catalog...');
                    this.logger.log('Refreshing model catalog', 'info');
                    
                    const modelListResponse = await fetch('https://esm.run/@mlc-ai/web-llm/lib/config.js')
                        .catch(() => null);
                    
                    let availableModels;
                    try {
                        availableModels = webllm.prebuiltAppConfig?.model_list || [];
                    } catch (error) {
                        // Fallback to default models if prebuilt config is not available
                        availableModels = APP_CONFIG.defaultModels.map(id => ({ model_id: id, model: id }));
                        this.logger.log('Using fallback model list', 'warning');
                    }
                    
                    this.logger.log(`Found ${availableModels.length} total models`, 'info');
                    
                    // Filter and sort models by suitability
                    const suitableModels = availableModels
                        .filter(model => {
                            const modelId = model.model_id || model.model || '';
                            const lowerModelId = modelId.toLowerCase();
                            
                            return lowerModelId.includes('tinyllama') || 
                                   lowerModelId.includes('phi') || 
                                   lowerModelId.includes('gemma') ||
                                   (lowerModelId.includes('llama') && lowerModelId.includes('7b')) ||
                                   lowerModelId.includes('mistral') ||
                                   lowerModelId.includes('qwen');
                        })
                        .sort((a, b) => {
                            const aId = (a.model_id || a.model).toLowerCase();
                            const bId = (b.model_id || b.model).toLowerCase();
                            
                            // Prioritize smaller models
                            if (aId.includes('tinyllama') && !bId.includes('tinyllama')) return -1;
                            if (!aId.includes('tinyllama') && bId.includes('tinyllama')) return 1;
                            if (aId.includes('phi') && !bId.includes('phi')) return -1;
                            if (!aId.includes('phi') && bId.includes('phi')) return 1;
                            
                            return aId.localeCompare(bId);
                        })
                        .slice(0, 20); // Limit for UI performance
                    
                    const select = document.getElementById('modelSelect');
                    if (select) {
                        select.innerHTML = '<option value="">Select a model...</option>';
                        
                        suitableModels.forEach(model => {
                            const modelId = model.model_id || model.model;
                            const option = document.createElement('option');
                            option.value = modelId;
                            
                            // Create informative labels
                            let label = modelId;
                            if (modelId.includes('TinyLlama') || modelId.includes('1.1B')) {
                                label += ' (Fast - Recommended)';
                            } else if (modelId.includes('Phi')) {
                                label += ' (Balanced)';
                            } else if (modelId.includes('7B')) {
                                label += ' (Large - Slower)';
                            }
                            
                            option.textContent = label;
                            select.appendChild(option);
                        });
                    }
                    
                    this.updateModelStatus(`Found ${suitableModels.length} compatible models`);
                    this.logger.log(`Loaded ${suitableModels.length} compatible models`, 'success');
                    
                } catch (error) {
                    const errorInfo = ErrorHandler.logError('Model refresh', error);
                    this.updateModelStatus('Failed to load model catalog');
                    this.logger.log(`Model refresh failed: ${error.message}`, 'error');
                    ErrorHandler.showError('Could not load model catalog', error.message, 'model-loading');
                }
            }

            async loadModel() {
                if (this.isLoading) {
                    this.logger.log('Model loading already in progress', 'warning');
                    return;
                }

                try {
                    const modelId = document.getElementById('modelSelect')?.value;
                    if (!modelId) {
                        InputValidator.showValidationError('modelSelect', 'Please select a model');
                        return;
                    }

                    InputValidator.clearValidationError('modelSelect');
                    this.isLoading = true;
                    this.retryCount = 0;
                    
                    await this.attemptModelLoad(modelId);
                    
                } catch (error) {
                    if (this.retryCount < APP_CONFIG.maxRetries) {
                        this.retryCount++;
                        this.logger.log(`Model loading failed, retrying (${this.retryCount}/${APP_CONFIG.maxRetries})`, 'warning');
                        
                        setTimeout(() => {
                            this.loadModel();
                        }, APP_CONFIG.retryDelay * this.retryCount);
                    } else {
                        const errorInfo = ErrorHandler.logError('Model loading', error);
                        this.updateModelStatus('Model loading failed');
                        this.hideLoadingScreen();
                        
                        let errorMessage = `Failed to load model after ${APP_CONFIG.maxRetries} attempts: ${error.message}`;
                        if (error.message.includes('Cannot find model record')) {
                            errorMessage += '\n\nTry selecting a different model or refreshing the model list.';
                        }
                        
                        ErrorHandler.showError(errorMessage, null, 'model-loading');
                        this.logger.log(`Model loading failed after ${APP_CONFIG.maxRetries} retries: ${error.message}`, 'error');
                    }
                } finally {
                    this.isLoading = false;
                }
            }

            async attemptModelLoad(modelId) {
                this.updateModelStatus('Loading model...');
                this.showLoadingScreen();
                this.logger.log(`Starting to load model: ${modelId}`, 'info');
                
                this.updateLoadingText(`Loading ${modelId}...`, 'This may take several minutes on first load');
                this.updateLoadingProgress(0);

                // Create abort controller with timeout
                this.abortController = new AbortController();
                const timeoutId = setTimeout(() => {
                    this.abortController.abort();
                }, APP_CONFIG.modelTimeoutMs);

                try {
                    // Attempt loading with progress callback
                    await this.engine.reload(modelId, undefined, (progress) => {
                        if (this.abortController.signal.aborted) {
                            throw new Error('Model loading was cancelled or timed out');
                        }
                        
                        if (progress && typeof progress.progress === 'number') {
                            const percent = Math.floor(progress.progress * 100);
                            this.updateLoadingProgress(percent);
                            this.updateLoadingText(
                                `Loading ${modelId}...`, 
                                `Progress: ${percent}% ${progress.text || ''}`
                            );
                            this.logger.log(`Loading progress: ${percent}%`, 'info');
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    this.currentModel = modelId;
                    document.getElementById('currentModelName').textContent = modelId;
                    
                    this.hideLoadingScreen();
                    this.updateModelStatus(`${modelId} loaded and ready`);
                    
                    const generateBtn = document.getElementById('generateBtn');
                    if (generateBtn) {
                        generateBtn.disabled = false;
                    }
                    
                    this.logger.log(`Model loaded successfully: ${modelId}`, 'success');
                    
                    // Test model with a simple prompt
                    await this.testModel();
                    
                } catch (error) {
                    clearTimeout(timeoutId);
                    
                    if (error.message.includes('cancelled') || error.message.includes('timed out')) {
                        throw new Error('Model loading timed out - try a smaller model or check your connection');
                    }
                    
                    throw error;
                } finally {
                    this.abortController = null;
                }
            }

            async testModel() {
                try {
                    this.logger.log('Testing model with simple prompt', 'info');
                    
                    const testCompletion = await this.engine.chat.completions.create({
                        messages: [{ role: "user", content: "Hello" }],
                        max_tokens: 1,
                        temperature: 1.0
                    });
                    
                    if (testCompletion && testCompletion.choices && testCompletion.choices.length > 0) {
                        this.logger.log('Model test successful', 'success');
                    } else {
                        throw new Error('Model test returned invalid response');
                    }
                    
                } catch (error) {
                    this.logger.log(`Model test failed: ${error.message}`, 'warning');
                    // Don't fail the entire load for test failures
                }
            }

            async generateAndAnalyze() {
                if (!this.currentModel || this.isGenerating) {
                    this.logger.log('Cannot start generation - model not ready or already generating', 'warning');
                    return;
                }
                
                try {
                    // Validate all inputs
                    if (!InputValidator.validateAll()) {
                        ErrorHandler.showError('Please fix validation errors before proceeding', null, 'validation');
                        return;
                    }
                    
                    const config = this.getCurrentConfiguration();
                    
                    this.isGenerating = true;
                    this.tokenData = [];
                    this.generationErrors = [];
                    this.visualizer.clear();
                    this.logger.clear();
                    this.performanceMonitor.startGeneration();
                    this.updateGenerationUI();
                    
                    this.logger.log('Starting token generation and analysis', 'info');
                    this.logger.log(`Configuration: ${JSON.stringify(config)}`, 'info');
                    
                    // Create abort controller for generation
                    this.abortController = new AbortController();
                    
                    const messages = [{ role: "user", content: config.prompt }];
                    
                    // Prepare generation config with safe parameters
                    const generationConfig = {
                        messages,
                        temperature: config.temperature,
                        max_tokens: config.maxTokens,
                        stream: true,
                        logprobs: true,
                        top_logprobs: Math.min(config.topK, 5) // Clamp to safe range
                    };
                    
                    this.logger.log('Creating chat completion stream', 'info');
                    
                    const stream = await this.engine.chat.completions.create(generationConfig);
                    
                    let tokenPosition = 0;
                    let successfulTokens = 0;
                    let lastUpdateTime = performance.now();
                    
                    this.logger.log('Processing token stream', 'info');
                    
                    for await (const chunk of stream) {
                        if (!this.isGenerating || this.abortController.signal.aborted) {
                            this.logger.log('Generation stopped by user', 'warning');
                            break;
                        }
                        
                        try {
                            tokenPosition++;
                            const tokenInfo = this.processTokenChunk(chunk, tokenPosition);
                            
                            if (tokenInfo) {
                                this.tokenData.push(tokenInfo);
                                successfulTokens++;
                                this.performanceMonitor.recordToken();
                                
                                // Throttled updates for performance
                                const now = performance.now();
                                if (now - lastUpdateTime > APP_CONFIG.updateThrottleMs) {
                                    this.updateRealTimeAnalysis(tokenInfo);
                                    this.visualizer.addToken(tokenInfo);
                                    this.updateGenerationProgress(tokenPosition, config.maxTokens);
                                    lastUpdateTime = now;
                                }
                                
                                if (this.configManager.get('verboseMode')) {
                                    this.logger.log(`Token ${tokenPosition}: "${tokenInfo.token}" (${(tokenInfo.probability * 100).toFixed(1)}%)`, 'success');
                                }
                                
                                // Small delay to prevent UI blocking
                                await new Promise(resolve => setTimeout(resolve, 10));
                            }
                            
                        } catch (tokenError) {
                            this.generationErrors.push(ErrorHandler.logError(`Token ${tokenPosition}`, tokenError));
                            this.logger.log(`Token processing error: ${tokenError.message}`, 'error');
                            
                            // Continue processing other tokens
                            continue;
                        }
                    }
                    
                    // Final update
                    if (this.tokenData.length > 0) {
                        const lastToken = this.tokenData[this.tokenData.length - 1];
                        this.updateRealTimeAnalysis(lastToken);
                        this.visualizer.addToken(lastToken);
                    }
                    
                    this.performanceMonitor.endGeneration();
                    this.logger.log(`Generation completed: ${successfulTokens}/${tokenPosition} tokens processed successfully`, 'success');
                    
                    if (this.generationErrors.length > 0) {
                        this.logger.log(`${this.generationErrors.length} errors occurred during generation`, 'warning');
                    }
                    
                    this.finalizeAnalysis();
                    
                    // Auto-export if enabled
                    if (this.configManager.get('autoExport')) {
                        this.exportData('json');
                    }
                    
                } catch (error) {
                    const errorInfo = ErrorHandler.logError('Generation', error);
                    this.logger.log(`Generation failed: ${error.message}`, 'error');
                    ErrorHandler.showError(`Generation failed: ${error.message}`, null, 'generation');
                    
                } finally {
                    this.isGenerating = false;
                    this.abortController = null;
                    this.updateGenerationUI();
                }
            }

            processTokenChunk(chunk, position) {
                try {
                    // Defensive extraction with comprehensive validation
                    const choice = chunk?.choices?.[0];
                    if (!choice) {
                        return null; // Skip empty chunks
                    }

                    const content = choice?.delta?.content;
                    const logprobs = choice?.logprobs;
                    
                    if (!content || !logprobs) {
                        return null; // Skip chunks without content or logprobs
                    }

                    const contentLogprobs = logprobs?.content?.[0];
                    if (!contentLogprobs) {
                        throw new Error('No content logprobs available');
                    }

                    const token = content;
                    const tokenLogprob = contentLogprobs.logprob;
                    
                    if (typeof tokenLogprob !== 'number' || isNaN(tokenLogprob)) {
                        throw new Error('Invalid token logprob');
                    }

                    const tokenProbability = Math.exp(tokenLogprob);
                    
                    // Extract alternatives with comprehensive validation
                    const alternatives = (contentLogprobs.top_logprobs || [])
                        .filter(alt => alt && typeof alt.logprob === 'number' && !isNaN(alt.logprob))
                        .map(alt => ({
                            token: alt.token || '',
                            logprob: alt.logprob
                        }))
                        .slice(0, 10); // Limit alternatives
                    
                    // Calculate metrics with enhanced error handling
                    const allProbs = alternatives.map(alt => {
                        const prob = Math.exp(alt.logprob);
                        return isFinite(prob) && prob > 0 ? prob : 0;
                    }).filter(p => p > 0);
                    
                    const entropy = StatisticalAnalysis.calculateEntropy(allProbs);
                    const surprisal = StatisticalAnalysis.calculateSurprisal(tokenProbability);
                    const perplexity = StatisticalAnalysis.calculatePerplexity(allProbs);
                    const uncertainty = StatisticalAnalysis.classifyUncertainty(entropy);
                    
                    return {
                        token,
                        position,
                        logprob: tokenLogprob,
                        probability: tokenProbability,
                        alternatives,
                        entropy,
                        surprisal,
                        perplexity,
                        uncertainty,
                        timestamp: Date.now(),
                        processingTime: performance.now()
                    };
                    
                } catch (error) {
                    throw new Error(`Token processing failed: ${error.message}`);
                }
            }

            updateRealTimeAnalysis(tokenInfo) {
                try {
                    // Update current metrics with enhanced safety checks
                    const updateElement = (id, value, formatter = (v) => v.toString()) => {
                        const element = document.getElementById(id);
                        if (element && value !== undefined && value !== null) {
                            element.textContent = formatter(value);
                        }
                    };

                    updateElement('currentEntropy', tokenInfo.entropy, v => v.toFixed(2));
                    updateElement('currentConfidence', tokenInfo.probability * 100, v => `${v.toFixed(1)}%`);
                    updateElement('currentSurprisal', tokenInfo.surprisal, v => v.toFixed(1));
                    updateElement('currentPerplexity', tokenInfo.perplexity, v => v.toFixed(1));
                    
                    // Update metric card styles with animation
                    const cards = ['entropyCard', 'confidenceCard', 'surprisalCard', 'perplexityCard'];
                    cards.forEach(cardId => {
                        const card = document.getElementById(cardId);
                        if (card) {
                            card.className = `metric-card uncertainty-${tokenInfo.uncertainty}`;
                        }
                    });
                    
                    // Update overlay information
                    updateElement('tokenCount', tokenInfo.position);
                    
                    if (this.tokenData.length > 0) {
                        const avgEntropy = this.tokenData.reduce((sum, t) => sum + (t.entropy || 0), 0) / this.tokenData.length;
                        updateElement('avgEntropy', avgEntropy, v => v.toFixed(2));
                    }
                    
                    // Update probability details with enhanced formatting
                    const details = this.formatProbabilityDetails(tokenInfo);
                    const detailsElement = document.getElementById('probabilityDetails');
                    if (detailsElement) {
                        detailsElement.innerHTML = details;
                    }
                    
                    // Update token sequence
                    this.updateTokenSequence();
                    
                    // Update status bar
                    updateElement('totalTokens', this.tokenData.length);
                    
                } catch (error) {
                    console.error('Error updating real-time analysis:', error);
                    this.logger.log(`UI update error: ${error.message}`, 'error');
                }
            }

            formatProbabilityDetails(tokenInfo) {
                try {
                    let html = `<strong>Token:</strong> "${tokenInfo.token || 'N/A'}"<br>`;
                    html += `<strong>Probability:</strong> ${(tokenInfo.probability * 100).toFixed(2)}% (log: ${tokenInfo.logprob.toFixed(3)})<br>`;
                    html += `<strong>Entropy:</strong> ${tokenInfo.entropy.toFixed(2)} bits<br>`;
                    html += `<strong>Surprisal:</strong> ${tokenInfo.surprisal.toFixed(2)} bits<br>`;
                    html += `<strong>Perplexity:</strong> ${tokenInfo.perplexity.toFixed(2)}<br>`;
                    html += `<strong>Uncertainty:</strong> ${tokenInfo.uncertainty}<br>`;
                    html += `<strong>Position:</strong> ${tokenInfo.position}<br><br>`;
                    
                    if (tokenInfo.alternatives && tokenInfo.alternatives.length > 1) {
                        html += `<strong>Top ${Math.min(5, tokenInfo.alternatives.length)} alternatives:</strong><br>`;
                        tokenInfo.alternatives.slice(0, 5).forEach((alt, index) => {
                            const prob = Math.exp(alt.logprob);
                            const isSelected = alt.token === tokenInfo.token;
                            const tokenDisplay = (alt.token || '').substring(0, 20);
                            const percentage = (prob * 100).toFixed(1);
                            html += `${index + 1}. "${tokenDisplay}" - ${percentage}%${isSelected ? ' ‚òÖ' : ''}<br>`;
                        });
                    }
                    
                    return html;
                } catch (error) {
                    return `<span style="color: var(--error);">Error formatting details: ${error.message}</span>`;
                }
            }

            updateTokenSequence() {
                try {
                    const tokenStream = document.getElementById('tokenStream');
                    if (!tokenStream) return;
                    
                    tokenStream.innerHTML = '';
                    
                    // Show last 30 tokens to avoid performance issues
                    const recentTokens = this.tokenData.slice(-30);
                    const currentIndex = this.tokenData.length - 1;
                    
                    recentTokens.forEach((tokenData, index) => {
                        const tokenEl = document.createElement('span');
                        tokenEl.className = `token ${tokenData.uncertainty}-uncertainty`;
                        tokenEl.textContent = (tokenData.token || '').substring(0, 10);
                        tokenEl.setAttribute('role', 'listitem');
                        tokenEl.setAttribute('title', `Token: "${tokenData.token}", Entropy: ${tokenData.entropy.toFixed(2)}, Position: ${tokenData.position}`);
                        
                        const actualIndex = this.tokenData.length - recentTokens.length + index;
                        if (actualIndex === currentIndex) {
                            tokenEl.classList.add('current');
                            tokenEl.setAttribute('aria-current', 'true');
                        }
                        
                        tokenEl.addEventListener('click', () => {
                            this.showTokenDetails(tokenData);
                        });
                        
                        tokenStream.appendChild(tokenEl);
                    });
                } catch (error) {
                    console.error('Error updating token sequence:', error);
                    this.logger.log(`Token sequence update error: ${error.message}`, 'error');
                }
            }

            showTokenDetails(tokenData) {
                try {
                    const alternativeTokens = document.getElementById('alternativeTokens');
                    if (!alternativeTokens) return;
                    
                    let html = '<div style="font-size: 11px; margin-bottom: 6px; color: var(--text-secondary);">';
                    html += `Token Details - Position ${tokenData.position}</div>`;
                    html += `<div style="margin-bottom: 8px; font-size: 10px;">`;
                    html += `<strong>Selected:</strong> "${tokenData.token}"<br>`;
                    html += `<strong>Probability:</strong> ${(tokenData.probability * 100).toFixed(2)}%<br>`;
                    html += `<strong>Entropy:</strong> ${tokenData.entropy.toFixed(2)} bits<br>`;
                    html += `<strong>Uncertainty:</strong> ${tokenData.uncertainty}`;
                    html += `</div>`;
                    
                    if (tokenData.alternatives && tokenData.alternatives.length > 0) {
                        html += '<div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px;">All Alternatives:</div>';
                        
                        tokenData.alternatives.forEach((alt, index) => {
                            const prob = Math.exp(alt.logprob);
                            if (!isFinite(prob)) return;
                            
                            const isSelected = alt.token === tokenData.token;
                            const altEl = `<div class="alternative-token ${isSelected ? 'selected' : ''}" style="${isSelected ? 'background: rgba(123, 179, 255, 0.2);' : ''}">
                                <span class="alternative-token-text">"${(alt.token || '').substring(0, 30)}"</span>
                                <span class="alternative-token-prob">${(prob * 100).toFixed(1)}%${isSelected ? ' ‚òÖ' : ''}</span>
                            </div>`;
                            html += altEl;
                        });
                    }
                    
                    alternativeTokens.innerHTML = html;
                    
                    // Switch to tokens tab
                    this.switchTab('tokens');
                } catch (error) {
                    console.error('Error showing token details:', error);
                    this.logger.log(`Token details error: ${error.message}`, 'error');
                }
            }

            finalizeAnalysis() {
                try {
                    // Calculate comprehensive statistics
                    if (this.tokenData.length >= 5) {
                        const entropies = this.tokenData
                            .map(t => t.entropy)
                            .filter(e => typeof e === 'number' && isFinite(e));
                        
                        const stats = StatisticalAnalysis.calculateStatistics(entropies);
                        
                        if (stats) {
                            const uncertaintyDistribution = {
                                high: this.tokenData.filter(t => t.uncertainty === 'high').length,
                                medium: this.tokenData.filter(t => t.uncertainty === 'medium').length,
                                low: this.tokenData.filter(t => t.uncertainty === 'low').length
                            };
                            
                            const total = this.tokenData.length;
                            
                            let statsHtml = `<div style="font-size: 11px; line-height: 1.5;">`;
                            statsHtml += `<strong>Entropy Statistics (n=${stats.count})</strong><br>`;
                            statsHtml += `Mean: ${stats.mean.toFixed(3)} ¬± ${stats.std.toFixed(3)}<br>`;
                            statsHtml += `Median: ${stats.median.toFixed(3)}<br>`;
                            statsHtml += `Range: ${stats.min.toFixed(3)} - ${stats.max.toFixed(3)}<br>`;
                            statsHtml += `IQR: ${stats.q25.toFixed(3)} - ${stats.q75.toFixed(3)}<br>`;
                            statsHtml += `Skewness: ${stats.skewness.toFixed(3)}<br>`;
                            statsHtml += `Kurtosis: ${stats.kurtosis.toFixed(3)}<br><br>`;
                            
                            statsHtml += `<strong>Uncertainty Distribution</strong><br>`;
                            statsHtml += `High: ${uncertaintyDistribution.high} tokens (${(uncertaintyDistribution.high / total * 100).toFixed(1)}%)<br>`;
                            statsHtml += `Medium: ${uncertaintyDistribution.medium} tokens (${(uncertaintyDistribution.medium / total * 100).toFixed(1)}%)<br>`;
                            statsHtml += `Low: ${uncertaintyDistribution.low} tokens (${(uncertaintyDistribution.low / total * 100).toFixed(1)}%)<br><br>`;
                            
                            // Add model confidence assessment
                            const avgEntropy = stats.mean;
                            let confidenceAssessment;
                            if (avgEntropy < 1.0) {
                                confidenceAssessment = 'High model confidence';
                            } else if (avgEntropy < 2.0) {
                                confidenceAssessment = 'Moderate model confidence';
                            } else {
                                confidenceAssessment = 'Low model confidence';
                            }
                            
                            statsHtml += `<strong>Assessment:</strong> ${confidenceAssessment}`;
                            statsHtml += `</div>`;
                            
                            const statsElement = document.getElementById('statsResults');
                            if (statsElement) {
                                statsElement.innerHTML = statsHtml;
                            }
                        }
                    }
                    
                    this.logger.log('Analysis finalized successfully', 'success');
                    
                } catch (error) {
                    console.error('Error finalizing analysis:', error);
                    this.logger.log(`Analysis finalization error: ${error.message}`, 'error');
                }
            }

            calculateAverageUncertainty() {
                if (this.tokenData.length === 0) return '-';
                
                try {
                    const validEntropies = this.tokenData
                        .map(t => t.entropy)
                        .filter(e => typeof e === 'number' && isFinite(e));
                    
                    if (validEntropies.length === 0) return '-';
                    
                    const avgEntropy = validEntropies.reduce((sum, e) => sum + e, 0) / validEntropies.length;
                    return StatisticalAnalysis.classifyUncertainty(avgEntropy);
                } catch (error) {
                    return '-';
                }
            }

            stopGeneration() {
                if (this.isGenerating && this.abortController) {
                    this.abortController.abort();
                    this.logger.log('Generation stop requested by user', 'warning');
                }
                this.isGenerating = false;
            }

            getCurrentConfiguration() {
                try {
                    return {
                        prompt: InputValidator.validatePrompt(document.getElementById('promptInput')?.value || ''),
                        temperature: InputValidator.validateTemperature(document.getElementById('tempSlider')?.value || '1.0'),
                        maxTokens: InputValidator.validateMaxTokens(document.getElementById('maxTokens')?.value || '20'),
                        topK: InputValidator.validateTopK(document.getElementById('topKValue')?.textContent || '5')
                    };
                } catch (error) {
                    throw new Error(`Configuration validation failed: ${error.message}`);
                }
            }

            updateGenerationProgress(current, max) {
                const progressElement = document.getElementById('generateProgress');
                if (progressElement) {
                    const percent = Math.min(100, (current / max) * 100);
                    progressElement.style.width = `${percent}%`;
                    progressElement.setAttribute('aria-valuenow', percent);
                }
            }

            updateGenerationUI() {
                const generateBtn = document.getElementById('generateBtn');
                const stopBtn = document.getElementById('stopBtn');
                const progressElement = document.getElementById('generateProgress');
                
                if (generateBtn) {
                    generateBtn.disabled = this.isGenerating || !this.currentModel;
                    const btnText = generateBtn.querySelector('span');
                    if (btnText) {
                        btnText.textContent = this.isGenerating ? 'Generating...' : 'Generate & Analyze';
                    }
                }
                
                if (stopBtn) {
                    stopBtn.disabled = !this.isGenerating;
                }
                
                if (progressElement) {
                    if (!this.isGenerating) {
                        progressElement.style.width = '0%';
                        progressElement.setAttribute('aria-valuenow', '0');
                    }
                }
            }

            switchTab(tabName) {
                // Update tab buttons with proper ARIA attributes
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    const isActive = tab.dataset.tab === tabName;
                    tab.classList.toggle('active', isActive);
                    tab.setAttribute('aria-selected', isActive);
                });
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.toggle('active', content.id === `${tabName}-content`);
                });
            }

            exportData(format) {
                if (this.tokenData.length === 0) {
                    ErrorHandler.showError('No data to export. Generate some tokens first.', null, 'export');
                    return;
                }

                try {
                    const exportData = {
                        metadata: {
                            experimentId: this.experimentId,
                            timestamp: new Date().toISOString(),
                            model: this.currentModel || 'Unknown',
                            prompt: document.getElementById('promptInput')?.value || '',
                            configuration: this.getCurrentConfiguration(),
                            appVersion: APP_CONFIG.version,
                            webllmVersion: "0.2.x",
                            generationErrors: this.generationErrors,
                            performanceMetrics: this.performanceMonitor.getMetrics(),
                            errorReport: ErrorHandler.getErrorReport()
                        },
                        tokens: this.tokenData,
                        statistics: this.tokenData.length >= 5 ? 
                            StatisticalAnalysis.calculateStatistics(this.tokenData.map(t => t.entropy)) : null,
                        logData: this.logger.export()
                    };

                    if (format === 'json') {
                        this.downloadJSON(exportData, `llm-analysis-${this.experimentId}.json`);
                    } else {
                        this.downloadCSV(exportData, `llm-analysis-${this.experimentId}.csv`);
                    }

                    const lastExportElement = document.getElementById('lastExport');
                    if (lastExportElement) {
                        lastExportElement.textContent = `Last export: ${new Date().toLocaleTimeString()} (${format.toUpperCase()})`;
                    }
                    
                    this.logger.log(`Data exported as ${format.toUpperCase()}`, 'success');

                } catch (error) {
                    const errorInfo = ErrorHandler.logError('Export', error);
                    ErrorHandler.showError(`Export failed: ${error.message}`, null, 'export');
                    this.logger.log(`Export failed: ${error.message}`, 'error');
                }
            }

            downloadJSON(data, filename) {
                const blob = new Blob([JSON.stringify(data, null, 2)], { 
                    type: 'application/json' 
                });
                this.downloadBlob(blob, filename);
            }

            downloadCSV(data, filename) {
                const headers = [
                    'position', 'token', 'probability', 'logprob', 'entropy', 
                    'surprisal', 'perplexity', 'uncertainty', 'timestamp'
                ];
                
                const rows = data.tokens.map(token => [
                    token.position || 0,
                    `"${(token.token || '').replace(/"/g, '""')}"`,
                    (token.probability || 0).toFixed(6),
                    (token.logprob || 0).toFixed(6),
                    (token.entropy || 0).toFixed(6),
                    (token.surprisal || 0).toFixed(6),
                    (token.perplexity || 0).toFixed(6),
                    token.uncertainty || 'unknown',
                    token.timestamp || Date.now()
                ]);
                
                const csvContent = [
                    '# LLM Probability Analysis Export',
                    `# Generated: ${new Date().toISOString()}`,
                    `# Model: ${data.metadata.model}`,
                    `# Experiment ID: ${data.metadata.experimentId}`,
                    `# Total Tokens: ${data.tokens.length}`,
                    '',
                    headers.join(','),
                    ...rows.map(row => row.join(','))
                ].join('\n');
                
                const blob = new Blob([csvContent], { type: 'text/csv' });
                this.downloadBlob(blob, filename);
            }

            downloadBlob(blob, filename) {
                try {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Download failed:', error);
                    ErrorHandler.showError('File download failed', error.message, 'download');
                }
            }

            shareConfiguration() {
                try {
                    const config = {
                        ...this.getCurrentConfiguration(),
                        model: this.currentModel,
                        timestamp: new Date().toISOString(),
                        version: APP_CONFIG.version
                    };
                    
                    const shareData = btoa(JSON.stringify(config));
                    const shareUrl = `${window.location.origin}${window.location.pathname}?config=${shareData}`;
                    
                    if (navigator.share) {
                        navigator.share({
                            title: 'LLM Analysis Configuration',
                            text: 'Check out this LLM probability analysis configuration',
                            url: shareUrl
                        });
                    } else if (navigator.clipboard) {
                        navigator.clipboard.writeText(shareUrl);
                        ErrorHandler.showError('Configuration URL copied to clipboard!', null, 'info');
                    } else {
                        // Fallback: show URL in a dialog
                        prompt('Copy this URL to share your configuration:', shareUrl);
                    }
                    
                    this.logger.log('Configuration shared', 'success');
                } catch (error) {
                    ErrorHandler.showError('Failed to share configuration', error.message, 'share');
                }
            }

            loadSharedConfiguration() {
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const configData = urlParams.get('config');
                    
                    if (configData) {
                        const config = JSON.parse(atob(configData));
                        
                        // Apply configuration to UI
                        if (config.prompt) {
                            const promptInput = document.getElementById('promptInput');
                            if (promptInput) promptInput.value = config.prompt;
                        }
                        
                        if (config.temperature) {
                            const tempSlider = document.getElementById('tempSlider');
                            const tempValue = document.getElementById('tempValue');
                            if (tempSlider) tempSlider.value = config.temperature;
                            if (tempValue) tempValue.textContent = config.temperature;
                        }
                        
                        if (config.maxTokens) {
                            const maxTokensInput = document.getElementById('maxTokens');
                            if (maxTokensInput) maxTokensInput.value = config.maxTokens;
                        }
                        
                        if (config.topK) {
                            const topKSlider = document.getElementById('topKSlider');
                            const topKValue = document.getElementById('topKValue');
                            if (topKSlider) topKSlider.value = config.topK;
                            if (topKValue) topKValue.textContent = config.topK;
                        }
                        
                        if (config.model) {
                            const modelSelect = document.getElementById('modelSelect');
                            if (modelSelect) {
                                // Try to select the model if it exists in the dropdown
                                const option = Array.from(modelSelect.options).find(opt => opt.value === config.model);
                                if (option) {
                                    modelSelect.value = config.model;
                                }
                            }
                        }
                        
                        this.logger.log('Shared configuration loaded', 'success');
                        ErrorHandler.showError('Configuration loaded from URL!', null, 'info');
                        
                        // Clean up URL
                        const newUrl = new URL(window.location);
                        newUrl.searchParams.delete('config');
                        window.history.replaceState(null, '', newUrl);
                    }
                } catch (error) {
                    console.warn('Failed to load shared configuration:', error);
                }
            }

            updateModelStatus(status, type = 'info') {
                const statusElement = document.getElementById('modelStatus');
                const indicator = document.getElementById('statusIndicator');
                
                if (statusElement) {
                    statusElement.textContent = status;
                }
                
                if (indicator) {
                    indicator.className = 'status-indicator';
                    
                    if (status.includes('Loading') || status.includes('Initializing')) {
                        indicator.classList.add('loading');
                    } else if (status.includes('ready') || status.includes('loaded')) {
                        indicator.classList.add('ready');
                    } else if (type === 'error' || status.includes('failed')) {
                        indicator.classList.add('error');
                    }
                }
            }

            updateLoadingText(text, details = '') {
                const textElement = document.getElementById('loadingText');
                const detailsElement = document.getElementById('loadingDetails');
                
                if (textElement) textElement.textContent = text;
                if (detailsElement) detailsElement.textContent = details;
            }

            updateLoadingProgress(percent) {
                const progressBar = document.getElementById('loadingProgressBar');
                if (progressBar) {
                    const clampedPercent = Math.max(0, Math.min(100, percent));
                    progressBar.style.width = `${clampedPercent}%`;
                    progressBar.setAttribute('aria-valuenow', clampedPercent);
                }
            }

            showLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'flex';
                }
            }

            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
            }

            pauseUpdates() {
                // Pause expensive operations when tab is not visible
                if (this.visualizer) {
                    this.visualizer.pauseAnimations = true;
                }
                this.logger.log('Updates paused (tab not visible)', 'info');
            }

            resumeUpdates() {
                // Resume operations when tab becomes visible
                if (this.visualizer) {
                    this.visualizer.pauseAnimations = false;
                    this.visualizer.scheduleRedraw();
                }
                this.logger.log('Updates resumed (tab visible)', 'info');
            }

            updateUI() {
                // Initialize UI state
                const generateBtn = document.getElementById('generateBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                if (generateBtn) generateBtn.disabled = true;
                if (stopBtn) stopBtn.disabled = true;
                
                // Load shared configuration if present
                this.loadSharedConfiguration();
                
                // Set up tooltips for help icons
                document.querySelectorAll('.help-tooltip').forEach(tooltip => {
                    tooltip.addEventListener('mouseenter', (e) => {
                        // Simple tooltip implementation
                        const title = e.target.getAttribute('title');
                        if (title) {
                            e.target.setAttribute('data-tooltip', title);
                            e.target.removeAttribute('title');
                        }
                    });
                });
            }

            cleanup() {
                try {
                    // Stop any ongoing generation
                    if (this.abortController) {
                        this.abortController.abort();
                    }
                    
                    // Clear timers
                    if (this.autoSaveTimer) {
                        clearInterval(this.autoSaveTimer);
                    }
                    
                    // Cleanup visualizer
                    if (this.visualizer) {
                        this.visualizer.destroy();
                    }
                    
                    // Reset state
                    this.isGenerating = false;
                    this.isLoading = false;
                    
                    // Save final session state
                    this.autoSaveSession();
                    
                    this.logger.log('Application cleanup completed', 'info');
                    
                } catch (error) {
                    console.error('Cleanup error:', error);
                }
            }

            // Utility method for retrying failed operations
            async retry(operation, maxRetries = APP_CONFIG.maxRetries, delay = APP_CONFIG.retryDelay) {
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        return await operation();
                    } catch (error) {
                        if (attempt === maxRetries) {
                            throw error;
                        }
                        
                        this.logger.log(`Operation failed, retrying (${attempt}/${maxRetries})`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, delay * attempt));
                    }
                }
            }

            // Method to get application health status
            getHealthStatus() {
                return {
                    engineStatus: this.engine ? 'initialized' : 'not_initialized',
                    modelStatus: this.currentModel ? 'loaded' : 'not_loaded',
                    generationStatus: this.isGenerating ? 'active' : 'idle',
                    errorCount: ErrorHandler.errorCount,
                    tokenCount: this.tokenData.length,
                    performanceMetrics: this.performanceMonitor.getMetrics(),
                    configStatus: this.configManager.getAll(),
                    timestamp: new Date().toISOString()
                };
            }
        }

        // Initialize application with comprehensive error handling
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Check for required browser features
                if (!window.TextDecoder || !window.fetch || !window.WebAssembly) {
                    throw new Error('Browser not supported - missing required features');
                }
                
                // Initialize the application
                const app = new RobustLLMAnalyzer();
                
                // Make app globally available for debugging
                if (APP_CONFIG.errorReporting) {
                    window.llmAnalyzer = app;
                }
                
                // Set up global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Emergency stop: Ctrl+Shift+Escape
                    if (e.ctrlKey && e.shiftKey && e.key === 'Escape') {
                        e.preventDefault();
                        if (app.isGenerating) {
                            app.stopGeneration();
                            ErrorHandler.showError('Generation stopped by emergency shortcut', null, 'info');
                        }
                    }
                    
                    // Debug info: Ctrl+Shift+D
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        e.preventDefault();
                        console.log('App Health Status:', app.getHealthStatus());
                        ErrorHandler.showError('Debug info logged to console', null, 'info');
                    }
                });
                
            } catch (error) {
                console.error('Failed to initialize application:', error);
                ErrorHandler.showError('Application failed to start', error.message, 'critical');
                
                // Show fallback UI
                document.body.innerHTML = `
                    <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; font-family: system-ui; text-align: center; padding: 20px;">
                        <h1 style="color: #e65555; margin-bottom: 16px;">‚ö†Ô∏è Application Failed to Start</h1>
                        <p style="color: #666; margin-bottom: 20px; max-width: 500px;">
                            The LLM Probability Analyzer could not initialize. This may be due to:
                        </p>
                        <ul style="color: #666; text-align: left; margin-bottom: 20px;">
                            <li>Unsupported browser (requires modern WebAssembly support)</li>
                            <li>Network connectivity issues</li>
                            <li>JavaScript execution restrictions</li>
                        </ul>
                        <p style="color: #666; margin-bottom: 20px;">
                            <strong>Error:</strong> ${error.message}
                        </p>
                        <button onclick="window.location.reload()" style="padding: 12px 24px; background: #7bb3ff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                            Retry Application
                        </button>
                    </div>
                `;
            }
        });

        // Global error handlers for unhandled exceptions
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            ErrorHandler.showError('An unexpected error occurred', event.error?.message || 'Unknown error', 'runtime');
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            ErrorHandler.showError('An unexpected error occurred', event.reason?.message || event.reason, 'promise');
            event.preventDefault(); // Prevent default browser behavior
        });

        // Performance monitoring
        if (APP_CONFIG.performanceTracking && window.performance && window.performance.observer) {
            try {
                const observer = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    entries.forEach((entry) => {
                        if (entry.duration > 100) { // Log slow operations
                            console.warn('Slow operation detected:', entry.name, `${entry.duration.toFixed(2)}ms`);
                        }
                    });
                });
                
                observer.observe({ entryTypes: ['navigation', 'resource'] });
            } catch (error) {
                console.warn('Performance monitoring not available:', error);
            }
        }

        // Service worker registration for offline capability (optional)
        if ('serviceWorker' in navigator && window.location.protocol === 'https:') {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => {
                    console.log('Service Worker registered:', registration);
                })
                .catch(error => {
                    console.log('Service Worker registration failed:', error);
                });
        }

        console.log(`üß† LLM Probability Analyzer v${APP_CONFIG.version} initialized`);
        console.log('Use Ctrl+Shift+D for debug info, Ctrl+Shift+Escape for emergency stop');

    </script>
</body>
</html>
